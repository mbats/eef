---
layout: specification
description: Architecture
---

## Introduction

The architecture spans multiple modules (plug-ins) spread over two projects: EEF itself, and Sirius.

The parts in EEF should stay independent of Sirius. Their responsibility is to *render* properties views and wizard/dialogs, and to *react* to the user interactions with them. To do this they will need a rich description how of the properties views must look and behave. This description will be provided by an external party (in our case, Sirius), using a data format and API defined in the EEF part. This description format may be in part defined using an EMF model, but this is not a hard requirement.

The parts in Sirius are responsible for giving the specifier a high-level configuration language, well integrated with the existing Sirius VSM language and editor, to specify the *look* of the properties views they want to contribute, their *behavior*, and the *context* under which their should be visible or not. From this specifier-oriented language, the Sirius part is also responsible to feed EEF with a corresponding description which conforms to the format and API it expects.

## EEF

Modules (plug-ins or sets or plug-ins):

* *View Description API*. Defines the low-level vocabulary used to describe the look and feel of the property views (may or may not be a metamodel, i.e. `eef.ecore`).
* *Widgets Library*. For each concept in the view description API, provides a *controller* which is able to render it in SWT/JFace and to bind the appropriate listeners.
* *Runtime/Coordinator*. Provides a generic `ITabDescriptorProvider` extension (sub-interface) which, given some input element to show (e.g. an `EObject` selected on a Sirius diagram), will ask the configured provider (in our case, Sirius) for the *View Description* to use, render the resulting description by instantiating/updating widgets from the library and setup the appropriate hooks to keep the view up-to-date when the input's state changes (i.e. the same element is still selected, but some property of it which impacts the property view has changed) and to delegate to the client (some) behaviors triggered by the end-user on the views (e.g. the user invoked a "direct edit" tool whose behavior is defined in a client-specific way, a `Tool` is the VSM in the case of Sirius).

### Concrete Example

1. The end-user has a Sirius diagram opened (let's say a UML diagram), with the *Properties* view visible. He selects a `DNodeContainer`  which representes a UML `Class` named `"Library"`. From an Eclipse point-of-view, the current selection is the `DNodeContainer` instance.
2. The Eclipse property view is notified of the selection change. One of its tab (the _Semantic_ tab), setup by Sirius, is implemented using EEF's `ITabDescriptorProvider` extension, itself configured to callback on Sirius.
3. EEF gets the notification of a new input, the `DNodeContainer`. It calls back on Sirius, which gives it both the *View Description* to use and the *effective input*, i.e. the root `EObject` to be considered as `self` in the property views and the secondary input (the `DNodeContainer.semanticElements`). This can be done using a plain `Map<String,Object>` with some predefined keys (e.g. `input`, `additionalElements`, etc.) which would be part of all evaluation contexts for interpreted/dynamic expressions. This top-level context can also contain Sirius-specific "global" variables like `view` which would reference the actual `DNodeContainer`, information about the session, etc.
4. The view description provided by Sirius indicates that a single *text entry* should be used. Two rather different approaches here:
   1. Sirius has already evaluated all the dynamic parts of the description. The view description it has given EEF contains plain values: the label of the text field should be `Class`, and its content should be `Library`. Additional rendering hints like the background color, font, additional decorators etc. are also explicitly provided in the description provided by Sirius. The EEF rendering as a SWT control is trivial in this case. The EEF text widget sets up a hook to notify the EEF runtime coordinator when the user validates a new text value in the text field (say, `Biblioth√®que `, with a space). When this happens, the EEF runtime notifies Sirius of the event, giving it the new text value and the element in the view description which produced the text widget (the EEF runtime keeps track of these mappings). Sirius executes the required action, as specified in the VSM by a standard Sirius tool (it, too, keeps track of which VSM element produced which EEF View Description element). Let's assume the VSM-side tool changes the class name, but after some normalization, and sets the name to `Bibliotheque` without the accent or ending space. Sirius updates the view description for the text field accordingly (setting the text value to `Bibliotheque`) and returns control to EEF, indicating that this particular element needs to be updated. The EEF runtime calls back the EEF text widget to refresh itself, showing the current value set in the view description.
   2. Sirius has produced a VSM-like view description, where all dynamic/interpreted parts are left as interpreted expressions. The label of the text field description is not `Class`, but `aql:self.eClass().name`; the value is not `Library` but `aql:self.name` (or `aql:self.defaultItemLabelProvider().getText(self)`). The EEF runtime/coordinator instanciates an EEF text widget with references to: an `IInterpreter`-like service (provided by Sirius at step 3, along with the effective input and view description), an evaluation context (where `self` maps to the top-level `input` variable in this simple case) and the text view description. The text widget uses the interpreter service when it sees fit to evaluate the expressions it need in its context, and produces an SWT widget with the same look as above. In this scenario, the text view description provided by Sirius contains an additional field, named `onValueChanged` with an interpreted expression whose value is `_sirius:#f20ba`. This refers to an internal-only Sirius interpreter, with an opaque identifier that Sirius can track back to "the behavior to execute on direct edit of this text field", as specified in the VSM (alternatively, this could be something like `aql:executeSiriusBehavior('platform:/plugin/the/vsm.odesign#path/to/the/tool/to/execute')`, but this seems less flexible and would hard-code a dependency to AQL). The text widget sets up an SWT listener so that when the user validates a new text value, the `onValueChanged` expression is evaluated. The evaluation context inherits from the one used to render the text widget, but adds new variables (which ones exactly would depend on the kind of widget/interaction triggered). In this case, an additional variable `arg0` with the new text value is provided (this is what most Sirius direct edit tools expect). Sirius identies the tool/behavior to execute given the id (or URL) in the expression as it would normally. The only difference is that the return value is a structured value which provides EEF some information about how much of the property view should be invalidated/refreshed according to the actual effects of the tool. How exactly Sirius determines this is still to be defined precisely (hints: by analyzing the transaction's effects, by considering the tools' `forceRefresh` value, the global _Auto Refresh_ preference, etc.). When the EEF text widget gets this return value, it provides it to the EEF runtime coordinator, which dispatches the "refresh/update" notifications to all the actual views impacted (including the EEF text widget at the origin of the interaction).

## Sirius

Modules (new or changes to exsiting ones):

* `org.eclipse.sirius`: The core metamodel, defined in `viewpoint.ecore`, must be changed to support the inclusion of view description models. We do not want to hard-code this dependency into the core, so what will be added is the ability to include additional types, unkown to Sirius core, inside the VSMs. More specifically, the `Group` top-level VSM element will be modified to contain instances of `VSMExtension`, a new abstract and empty type. The support for creation of these will be based on EMF's standard support for child extenders.
* `org.eclipse.sirius.properties`: This new plug-in will define a `properties.ecore` metamodel, which defines the high-level vocabulary used by specifiers to configure the look and behavior of the properties views they want, and configure the contexts under which their should be visible or not. Its root element will extend the `VSMExtension` type defined in `viewpoint.ecore`.
  * Part of this metamodel will match more or less closely the *View Description* model/API defined by EEF, but will be free to reuse concepts, types and terminology common to Sirius without introducing undue dependencies. It will also be free do define more complex concepts (e.g. reuses, imports/overrides) which exist purely to ease the work of the specifier but add no actual functionality (without these, it would still be possible to obtain the same behavior, it would just be very cumbersome to write and maintain the corresponding VSMs). The EEF part of the equation will not be impacted by changes in this.
  * Another part of this (maybe in another metamodel) will deal with the _wiring_: define which of the views should be shown on a given selection, depending for example on the mapping selected. The conditions under which a property view element is visible/enabled may depend on: the state of the selected element, its type (meta-model-level conditions), the mapping and active style used to represent it, the view (`DRepresentationElement`), the representation and its current state (e.g. for a diagram, which layers and filters are enabled), the session and its current state (e.g. which viewpoints are enabled).
* `org.eclipse.sirius.ui.properties`: This new plug-in will, when installed, will take over the _Semantic_ tab of the properties view shown for Sirius. When an element is selected, it will use the information provided in the active VSMs to produce a _View Description_ instance which implements the semantics defined in the VSM, with all the associated elements mentioned above (an `IInterpreter`-like service reference, global context variables...) and hand over to the EEF runtime to render the UI and call it back when needed. It will be responsible to notify the EEF runtime to refresh all or parts of the UI when the semantic elements have changed (outside of the properties view control) and/or the "compiled" _View Description_ (e.g. because the user has enabled a new layer on a diagram, which contributed additional property sections) and/or when the VSM itself has changed (when in "live" mode, though from the EEF point of view this should be no different that the previous case; it's simply an update in the _View Description_ to render).

### Concrete Example
