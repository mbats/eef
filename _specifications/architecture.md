---
layout: specification
description: Architecture
---

## Introduction

The architecture spans multiple modules (plug-ins) spread over two projects: EEF itself, and Sirius.

The parts in EEF should stay independent of Sirius. Their responsibility is to *render* properties views and wizard/dialogs, and to *react* to the user interactions with them. To do this they will need a rich description how of the properties views must look and behave. This description will be provided by an external party (in our case, Sirius), using a data format and API defined in the EEF part. This description format may be in part defined using an EMF model, but this is not a hard requirement.

The parts in Sirius are responsible for giving the specifier a high-level configuration language, well integrated with the existing Sirius VSM language and editor, to specify the *look* of the properties views they want to contribute, their *behavior*, and the *context* under which their should be visible or not. From this specifier-oriented language, the Sirius part is also responsible to feed EEF with a corresponding description which conforms to the format and API it expects.

## EEF

Modules (plug-ins or sets or plug-ins):

* *View Description API*. Defines the low-level vocabulary used to describe the look and feel of the property views (may or may not be a metamodel, i.e. `eef.ecore`).
* *Widgets Library*. For each concept in the view description API, provides a *controller* which is able to render it in SWT/JFace and to bind the appropriate listeners.
* *Runtime/Coordinator*. Provides a generic `ITabDescriptorProvider` extension (sub-interface) which, given some input element to show (e.g. an `EObject` selected on a Sirius diagram), will ask the configured provider (in our case, Sirius) for the *View Description* to use, render the resulting description by instantiating/updating widgets from the library and setup the appropriate hooks to keep the view up-to-date when the input's state changes (i.e. the same element is still selected, but some property of it which impacts the property view has changed) and to delegate to the client (some) behaviors triggered by the end-user on the views (e.g. the user invoked a "direct edit" tool whose behavior is defined in a client-specific way, a `Tool` is the VSM in the case of Sirius).

Example:

1. The end-user has a Sirius diagram opened (let's say a UML diagram), with the *Properties* view visible. He selects a `DNodeContainer`  which representes a UML `Class` named `"Library"`. From an Eclipse point-of-view, the current selection is the `DNodeContainer` instance.
2. The Eclipse property view is notified of the selection change. One of its tab (the _Semantic_ tab), setup by Sirius, is implemented using EEF's `ITabDescriptorProvider` extension, itself configured to callback on Sirius.
3. EEF gets the notification of a new input, the `DNodeContainer`. It calls back on Sirius, which gives it both the *View Description* to use and the *effective input*, i.e. the root `EObject` to be considered as `self` in the property views and the secondary input (the `DNodeContainer.semanticElements`). This can be done using a plain `Map<String,Object>` with some predefined keys (e.g. `input`, `additionalElements`, etc.) which would be part of all evaluation contexts for interpreted/dynamic expressions. This top-level context can also contain Sirius-specific "global" variables like `view` which would reference the actual `DNodeContainer`, information about the session, etc.
4. The view description provided by Sirius indicates that a single *text entry* should be used. Two rather different approaches here:
   1. Sirius has already evaluated all the dynamic parts of the description. The view description it has given EEF contains plain values: the label of the text field should be `Class`, and its content should be `Library`. Additional rendering hints like the background color, font, additional decorators etc. are also explicitly provided in the description provided by Sirius. The EEF rendering as a SWT control is trivial in this case. The EEF text widget sets up a hook to notify the EEF runtime coordinator when the user validates a new text value in the text field (say, `Biblioth√®que `, with a space). When this happens, the EEF runtime notifies Sirius of the event, giving it the new text value and the element in the view description which produced the text widget (the EEF runtime keeps track of these mappings). Sirius executes the required action, as specified in the VSM by a standard Sirius tool (it, too, keeps track of which VSM element produced which EEF View Description element). Let's assume the VSM-side tool changes the class name, but after some normalization, and sets the name to `Bibliotheque` without the accent or ending space. Sirius updates the view description for the text field accordingly (setting the text value to `Bibliotheque`) and returns control to EEF, indicating that this particular element needs to be updated. The EEF runtime calls back the EEF text widget to refresh itself, showing the current value set in the view description.
   2. Sirius has produced a VSM-like view description, where all dynamic/interpreted parts are left as interpreted expressions. The label of the text field description is not `Class`, but `aql:self.eClass().name`; the value is not `Library` but `aql:self.name` (or `aql:self.defaultItemLabelProvider().getText(self)`). The EEF runtime/coordinator instanciates an EEF text widget with references to: an `IInterpreter`-like service (provided by Sirius at step 3, along with the effective input and view description), an evaluation context (where `self` maps to the top-level `input` variable in this simple case) and the text view description. The text widget uses the interpreter service when it sees fit to evaluate the expressions it need in its context, and produces an SWT widget with the same look as above. In this scenario, the text view description provided by Sirius contains an additional field, named `onValueChanged` with an interpreted expression whose value is `_sirius:#f20ba`. This refers to an internal-only Sirius interpreter, with an opaque identifier that Sirius can track back to "the behavior to execute on direct edit of this text field", as specified in the VSM (alternatively, this could be something like `aql:executeSiriusBehavior('platform:/plugin/the/vsm.odesign#path/to/the/tool/to/execute')`, but this seems less flexible and would hard-code a dependency to AQL). The text widget sets up an SWT listener so that when the user validates a new text value, the `onValueChanged` expression is evaluated. The evaluation context inherits from the one used to render the text widget, but adds new variables (which ones exactly would depend on the kind of widget/interaction triggered). In this case, an additional variable `arg0` with the new text value is provided (this is what most Sirius direct edit tools expect). Sirius identies the tool/behavior to execute given the id (or URL) in the expression as it would normally. The only difference is that the return value is a structured value which provides EEF some information about how much of the property view should be invalidated/refreshed according to the actual effects of the tool. How exactly Sirius determines this is still to be defined precisely (hints: by analyzing the transaction's effects, by considering the tools' `forceRefresh` value, the global _Auto Refresh_ preference, etc.). When the EEF text widget gets this return value, it provides it to the EEF runtime coordinator, which dispatches the "refresh/update" notifications to all the actual views impacted (including the EEF text widget at the origin of the interaction).

## Sirius

TBD
